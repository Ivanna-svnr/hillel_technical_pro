 // в короткому коментарі вказано отриманий результат
 /* в кількарядковому коментарі пояснення
 до завдання
 */
 // number33
/* 'number' + 3 + 3
‘number’ це тип даних string
Операція лівоасоціативна, після прочитання ‘number’ як string решта даних також сприймається як string, тому відбувається конкатенація (склеювання операндів).
*/


// 3
/* null + 3
тип даних null не має значення, умовно це ніщо
Відбувається арифметична операція додавання
Ніщо додати 3 отримуємо 3
*/

// qwerty
/* 5 && "qwerty"
&& - логічний оператор “і” поверне булеві значення
Якщо перший операнд false, то повернеться він
Але в нас перший операнд “5” - тип даних number матиме булеве значення true
Тому оскільки перший операнд не false, повертається другий операнд
*/


// 42hillel
/* +'40' + +'2' + "hillel"
значення 40 і 2 взяті в лапки це тип даних string, але унарний + перед значенням перетворює його в number
З першими двома операндами відбувається додавання, а третій операнд який є стрічкою “приклеюється”
*/

// false
/* '10' - 5 === 6
операція відбувається з ліва направо і першою є операція віднімання
Всі значення зводяться до типу даних number
10 - 5 = 5
Маємо 5 === 6, оскільки === оператор строгої рівності, який порівнює значення і типи даних, ми отримаємо false
Типи даних у нас однакові (number), але значення не рівні 
*/

// 1
/* true + false
відбувається приведення даних до числа
true це 1
false це 0
0 + 1 = 1
*/

// NaN
/* '4px' - 3
‘4px’ - тип даних string не можна привести до типу number через наявність літер
Відбувається спроба здійснити арифметичну операцію віднімання з типами даних string i number, що неможливо
*/ 

// 1
/* '4' - 3
‘4’ це string, але його можна привести до number, 
Відбувається арифметична операція віднімання
4 - 3 = 1
*/

// 61
/* '6' + 3 ** 0
у цьому випадку пріоритет надається операції зведення до ступеню ** , тому вона відбудеться першою
3 в ступені нуль дорівнює 1
‘6’ це string, оскільки  у нас використано оператор ‘+’, відбувається конкатенація
Якби тут використовували оператор ‘-‘, отримали б 6 - 1 = 5, але оператор ‘+’ не однозначний
*/

// 2
/* 12 / '6'
відбувається арифметична операція ділення
12 тип даних number
‘6’ це string
Другий операнд приводиться теж до числа
12 поділити на 6 дорівнює 2
*/

// 10false
/* '10' + (5 === 6) 
’10’ це string, оскільки операція виконується зліва направо, решта виразу буде теж записана як стріне
(5===6) має значення false, їхні значення не рівні, хоча тип даних number
Як результат отримуємо склеювання операндів ’10’ + false
*/

// false
/* null == ''
null не має жодного значення, булеве значення false
‘’ це string, стрічка має булеве значення true
Виходить false == true, в результаті отримаємо false
*/

// 27
/* 3 ** (9 / 3) 
Операція в дужках в пріоритеті
9/3 = 3
Після цього виконуємо решту зліва на право
3 підноситься до третього ступеню
3**3 = 27
*/

// true
/* !!'false' == !!'true'
маємо ‘false’ і ‘true’, які є типом даних стрічка, оскільки взяті в лапки
!! це спосіб перетворення даних на boolean
Значення стрічки завжди зводиться до true
Приблизно маємо true === true
*/

// 1
/* 0 || '0' && 1
логічний оператор && (і) має пріоритет над || (або), тому операція ‘0’ && 1 відбуватиметься першою
‘0’ має булеве значення true оскільки це string, 1 має булеве значення теж true, оскільки перше значення true повертаємо друге значення - true
Після чого маємо 0 || 1
0 має значення false
1 має значення true
Повертаємо значення 1, оскільки якщо перше значення false має повернутись друге значення
*/ 

// true
/* (+null == false) < 1
Унарний + перетворює значення +null на число 0, булеве значення якого false, оскільки порівнюються значення то вираз +null == false отримає значення true
true < 1 при приведенні до числа отримаємо 1 < 1, що неправильно і отримаємо в результаті false
*/


// true
/* false && true || true
перша операція false && true, пріоритет у оператора &&
Перше значення тут false, тому зупиняємось тут і повертаємо значення false
Друга операція тепер false || true - якщо перше значення 
false, то повертаємо друге значення
*/

// false
/* false && (false || true)
першою операцією буде false || true - вона в дужках, тому в даному випадку саме вона має пріоритет
Перше значення false, тому повертаємо друге значення true
Друга операція  false && true - перше значення false, тому зупиняємось на ньому і повертаємо результат false
*/

// false
/* (+null == false) < 1 ** 5
Унарний + перетворює значення +null на число 0, булеве значення якого false, оскільки порівнюються значення то вираз +null == false отримає значення true
1 в п’ятому ступені це 1
Маємо true < 1
Приводимо до числового значення, true це 1
1 < 1 отримуємо false
*/


